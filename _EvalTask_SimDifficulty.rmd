---
title: "Evaluating task and vet sim difficulty."
output: 
  html_document:
    toc: true
    toc_depth: 2
---

```{r setup_condensed, include=F}
## Setup
library("knitr")
knitr::opts_chunk$set(
  echo = F,
  message   = F, warning = F, error = F,
  results   = "asis",                # Opts: "asis", "markup", "hold", "hide"
  fig.align = "center",              # Opts: "left", "right", "center", "default"
  fig.width = 8, fig.height = 5,
  out.width = "100%",
  fig.pos   = "h", out.extra   = "", # Figures forced closer to chunk location.
  collapse  = TRUE, cache = FALSE, cache.lazy  = FALSE
)
```

```{r init}
## Initialize
library("spinifex")
library("tourr")
library("ggplot2")
library("tibble")

dat <- tourr::rescale(tourr::flea[,1:6])
rb       <- basis_random(n = ncol(dat))
class    <- tourr::flea$species

invisible(capture.output(holes_path <- save_history(dat, tour_path = guided_tour(holes()))))
holes_basis <- as.matrix(holes_path[,, dim(holes_path)[3]])

n <- nrow(dat)
p <- ncol(dat)
k_cl <- length(unique(class))
pca_obj <- prcomp(dat)

pca_var_rate <- pca_obj$sdev^2 / sum(pca_obj$sdev^2)

df_pcaVar <- data.frame(
  pc_number = paste0("PC", 1:p),
  rate_var_explained = pca_var_rate,
  cumsum_rate_var_explained = cumsum(pca_var_rate)
)
```

# Measuring which variables are sensitive to cluster seperation

Consider a sree plot of flea data. This shows which componets are contributing to the *full sample, full dimensionality,* $[n,p]$ variation of the data.

```{r Screeplot}
(g1 <- ggplot(data = df_pcaVar) + 
   ## Individual var bars
   geom_bar(stat = "identity", 
            mapping = aes(x = pc_number, y = rate_var_explained, 
                          fill = "Individual var explained")) + 
   ## Cummulative var line
   geom_line(mapping = aes(x = pc_number, y = cumsum_rate_var_explained,
                           color = "Cumsum of var explained", group = 1),lwd = 1.2) +
   geom_point(mapping = aes(x = pc_number, y = cumsum_rate_var_explained,
                            color = "Cumsum of var explained"), shape = 18, size = 4) +
   ## Themes, legends and colors 
   theme_minimal() +
   labs(title = "pca screeplot of normalized flea data",
        x = "Component number", 
        y = "Variance explained",
        colour = "", fill = "") + 
   # theme(legend.position = c(0.9, 0.5)) + ## legend position doesn't work now because different geoms??
   scale_fill_manual(values = "#1B9E77") + 
   scale_colour_manual(values = "#D95F02"))
# RColorBrewer::brewer.pal(n=2, "Dark2")
```

The user study task trys to explore the *full sample, full dimensionality* $[n,p]$ seperation of two specified clusters. In an analogous manner, __let's try to create a screeplot-like output to evalute the contributions of the original variables.__

```{r lda}
DO_RUN <- FALSE
if (DO_RUN) {
  .cl  <- unique(class)[1:2]
  .sub <- dat[class == .cl, ]
  .lda_dat <- data.frame(.sub, species = class[class == .cl]) 
  
  library(MASS)
  (lda_obj <- lda(species~., data = .lda_dat))
}
```

This happens to be precisely the setup for Linear Discriminant Analysis (LDA) (Fisher, 1936). Start by finding cluster means (originally had considered median). We have:

```{r clusterMeans}
mat_clusterMeans <- NULL
for (i in 1:k_cl) {
  .cl  <- unique(class)[i]
  .sub <- dat[class == .cl, ]
  .row <- apply(.sub, 2, mean)
  mat_clusterMeans <- rbind(mat_clusterMeans, .row)
}
kable(round(mat_clusterMeans,2), row.names = unique(class))
``` 


Suppose the clusters in questions are *Concinna* and *Heptapot*, now let's find the $p$-dim line between the cluster means. Let of the cluster mean of *Concinna* be the constant vetor (offset from origin). The vector between the cluser means is the slope, the $p$-dim, coefficients.

```{r clMeansAsPLine}
df_pLine_clusterMeans_CH <- as.data.frame(mat_clusterMeans[1:2, ])
rownames(df_pLine_clusterMeans_CH) <- c(("constants_ConcinnaHeptapot"), ("coefficients_ConcinnaHeptapot"))

kable(round(df_pLine_clusterMeans_CH, 2))
``` 

We have a vector of variable-coffecients corisponding to the sepration of the cluster means. Now we need to account for the variation held within the variables. To do so we need scale each variable the reciporical of the covariance matrix:

```{r InvCov, fig.cap="inverse of the covariance matrix"}
.cov_inverse <- 1 / cov(dat)
```

Solving for the product

$$ Cluster Seperation_{[1,p]} = Coefficients{[1, p]} * Covariance(flea)_{[p, p]}^{(-1)} =$$
```{r clusterSep}
df_clusterSep_CH <- .cov_inverse * df_pLine_clusterMeans_CH[2, ]
rownames(df_clusterSep_CH) <- "clusterSeperation_ConcinnaHeptapot"
df_clusterSep_CH
```

This is the remaining variable coefficents that best describe the *full sample, full dimensionality* seperation of the cluster means between *Concinna* and *Heptapot* after controling for variance and covariances. We discard the sign as we only care about magnitude of seperation. Now let's visualize this similar to the screeplot.

```{r clSepScreeplot}
.clSep <- abs(df_clusterSep_CH)
.clSep_rate <- t(.clSep[order(.clSep, decreasing = T)]) / sum(.clSep)
.var_nm_ord <- factor(row.names(.clSep_rate), levels=unique(row.names(.clSep_rate)))

df_Scree_ClSep <- data.frame(variable = .var_nm_ord,
                       rate_clSep = as.vector(.clSep_rate),
                       cumsum_rate_clSep = cumsum(.clSep_rate))

(g2 <- ggplot(data = df_Scree_ClSep) + 
    ## Individual clSep bars
    geom_bar(stat = "identity", 
             mapping = aes(x = variable, y = rate_clSep, 
                           fill = "Individual clSep explained")) + 
    ## Cummulative clSep line
    geom_line(mapping = aes(x = variable, y = cumsum_rate_clSep, group = 1,
                            color = "Cumsum of clSep explained"), lwd = 1.2) +
    geom_point(mapping = aes(x = variable, y = cumsum_rate_clSep,
                             color = "Cumsum of clSep explained"), shape = 18, size = 4) +
    ## Themes, legends and colors 
    theme_minimal() +
    labs(title = "Variables contributions to the seperation of cluster means [Concinna-Heptapot]",
         x = "Variable", 
         y = "Seperation of cluster means", 
         colour = "", fill = "") + 
    # theme(legend.position = c(0.9, 0.5)) + ## legend position doesn't work now because different geoms??
    scale_fill_manual(values = "#1B9E77") + 
    scale_colour_manual(values = "#D95F02"))
# RColorBrewer::brewer.pal(n=5, "Dark2")
```


# Evaluating the response

Now that we have a measure we want to define an objective cutoff for evaluation. We bin the seperation of clusters into 3 even bands relative to the max and assigned values of 0, 1, and 2 with increaing importance. Note that at least 1 variable must be "very important".

```{r answer}
bar100 <- max(.clSep_rate)
bar.66 <- 2 / 3 * bar100
bar.33 <- 1 / 3 * bar100

g2 +
  geom_rect(fill = "#7570B3", alpha = 0.05,
            mapping = aes(xmin = .3, xmax = 6.8, ymin = bar.66, ymax = bar100)) +
    geom_text(aes(x = 6.5, y = bar100 +.04, 
                  label = "max(single variable cluster seperation) | sample"), 
              size = 4, hjust = 1) +
  geom_hline(yintercept = bar100) +
  geom_text(aes(x = 6.5, y = bar.66 + .07, label = "very important -> 2"), 
            size = 4, hjust = 1) +
  geom_rect(fill = "#E7298A", alpha = 0.05,
            mapping = aes(xmin = .3, xmax = 6.8, ymin = bar.33, ymax = bar.66)) +
  geom_text(aes(x = 6.5, y = bar.33 + .07, label = "somewhat important -> 1"), 
            size = 4, hjust = 1) +
  geom_rect(fill = "#66A61E", alpha = 0.05,
            mapping = aes(xmin = .3, xmax = 6.8, ymin = 0, ymax = bar.33)) +
  geom_text(aes(x = 6.5, y = 0 + .07, label = "not important -> 0"), 
            size = 4, hjust = 1)
```

We make a $p$-length answer vector for the data set and find the variable-wise differnece with the response vector and aggregate over each variable acording to a measure where a larger value is worse.

$$MarksOff = \sum_{i = 1}^{p}(Answer_i - Response_i)^2$$

```{r exampleScoring}
df_Scree_ClSep$ptile_clSep <- df_Scree_ClSep$rate_clSep / bar
df_taskEval <- data.frame(
  variable = df_Scree_ClSep$variable,
  answer =  dplyr::case_when(df_Scree_ClSep$rate_clSep > bar.66 ~ 2,
                             df_Scree_ClSep$rate_clSep > bar.33 ~ 1,
                             df_Scree_ClSep$rate_clSep >= 0 ~ 0),
  exampleResponse = c(2, 1, 1, 2, 0, 1))
df_taskEval$delta <- df_taskEval$answer - df_taskEval$exampleResponse
df_taskEval$var_marksOff <- df_taskEval$delta^2

kable(df_taskEval)
cat(paste0("total MarksOff = ", sum(df_taskEval$var_marksOff)))
```

# Simulation difficulty

_To be continued..._






# References


Fisher, Ronald A. "The Use of Multiple Measurements in Taxonomic Problems." Annals of Eugenics 7, no. 2 (September 1936): 179-88. https://doi.org/10.1111/j.1469-1809.1936.tb02137.x.


