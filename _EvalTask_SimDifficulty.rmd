---
title: "Evaluating task and vet sim difficulty."
output: 
  html_document:
    toc: true
    toc_depth: 2
---

```{r setup_condensed, include=F}
## Setup
library("knitr")
knitr::opts_chunk$set(
  echo = F,
  message   = F, warning = F, error = F,
  results   = "asis",                # Opts: "asis", "markup", "hold", "hide"
  fig.align = "center",              # Opts: "left", "right", "center", "default"
  fig.width = 8, fig.height = 5,
  out.width = "100%",
  fig.pos   = "h", out.extra   = "", # Figures forced closer to chunk location.
  collapse  = TRUE, cache = FALSE, cache.lazy  = FALSE
)
```

```{r init}
## Initialize
library("spinifex")
library("tourr")
library("ggplot2")
library("tibble")

dat <- tourr::rescale(tourr::flea[,1:6])
rb       <- basis_random(n = ncol(dat))
class    <- tourr::flea$species

invisible(capture.output(holes_path <- save_history(dat, tour_path = guided_tour(holes()))))
holes_basis <- as.matrix(holes_path[,, dim(holes_path)[3]])

n <- nrow(dat)
p <- ncol(dat)
k_cl <- length(unique(class))
pca_obj <- prcomp(dat)

pca_var_rate <- pca_obj$sdev^2 / sum(pca_obj$sdev^2)

df_pcaVar <- data.frame(
  pc_number = paste0("PC", 1:p),
  rate_var_explained = pca_var_rate,
  cumsum_rate_var_explained = cumsum(pca_var_rate)
)
```
# Cluster seperation and task evalution

## Measuring which variables are sensitive to cluster seperation

Consider a sree plot of flea data. This shows which componets are contributing to the *full sample, full dimensionality,* $[n,p]$ variation of the data.

```{r Screeplot}
(g1 <- ggplot(data = df_pcaVar) + 
   ## Individual var bars
   geom_bar(stat = "identity", 
            mapping = aes(x = pc_number, y = rate_var_explained, 
                          fill = "Individual var explained")) + 
   ## Cummulative var line
   geom_line(mapping = aes(x = pc_number, y = cumsum_rate_var_explained,
                           color = "Cumsum of var explained", group = 1),lwd = 1.2) +
   geom_point(mapping = aes(x = pc_number, y = cumsum_rate_var_explained,
                            color = "Cumsum of var explained"), shape = 18, size = 4) +
   ## Themes, legends and colors 
   theme_minimal() +
   labs(title = "pca screeplot of normalized flea data",
        x = "Component number", 
        y = "Variance explained",
        colour = "", fill = "") + 
   # theme(legend.position = c(0.9, 0.5)) + ## legend position doesn't work now because different geoms??
   scale_fill_manual(values = "#1B9E77") + 
   scale_colour_manual(values = "#D95F02"))
# RColorBrewer::brewer.pal(n=2, "Dark2")
```

The user study task trys to explore the *full sample, full dimensionality* $[n,p]$ seperation of two specified clusters. In an analogous manner, __let's try to create a screeplot-like output to evalute the contributions of the original variables.__

```{r lda, eval=FALSE}
#### USES EVAL

.cl  <- unique(class)[1:2]
.sub <- dat[class == .cl, ]
.lda_dat <- data.frame(.sub, species = class[class == .cl]) 

library(MASS)
(lda_obj <- lda(species~., data = .lda_dat))
```

This happens to be precisely the setup for Linear Discriminant Analysis (LDA) (Fisher, 1936). Start by finding cluster means (originally had considered median). We have:

```{r clusterMeans}
mat_clusterMeans <- NULL
for (i in 1:k_cl) {
  .cl  <- unique(class)[i]
  .sub <- dat[class == .cl, ]
  .row <- apply(.sub, 2, mean)
  mat_clusterMeans <- rbind(mat_clusterMeans, .row)
}

## Prep display
.disp_df_clusterMeans <- round(mat_clusterMeans, 2)
rownames(.disp_df_clusterMeans) <- unique(class)
kable(.disp_df_clusterMeans)
``` 


Suppose the clusters in questions are *Concinna* and *Heptapot*, now let's find the $p$-dim line between the cluster means. Let of the cluster mean of *Concinna* be the constant vetor (offset from origin). The vector between the cluser means is the slope, the $p$-dim, coefficients.

```{r clMeansAsPLine}
df_pLine_clusterMeans_CH <- as.data.frame(mat_clusterMeans[1:2, ])
rownames(df_pLine_clusterMeans_CH) <- c(("constants_ConcinnaHeptapot"), ("coefficients_ConcinnaHeptapot"))

kable(round(df_pLine_clusterMeans_CH, 2))
``` 

We have a vector of variable-coffecients corisponding to the sepration of the cluster means. Now we need to account for the variation held within the variables. To do so we need scale each variable the reciporical of the covariance matrix:

Solving for the product

$$ Cluster Seperation_{[1,p]} = Coefficients{[1, p]} * 1/Covariance(flea)_{[p, p]}$$

```{r clusterSep}
.inverse_covar <- 1 / cov(dat)
df_clusterSep_CH <- .inverse_covar * df_pLine_clusterMeans_CH[2, ]
rownames(df_clusterSep_CH) <- "clusterSeperation_ConcinnaHeptapot"

kable(round(df_clusterSep_CH, 2))
```

This is the remaining variable coefficents that best describe the *full sample, full dimensionality* seperation of the cluster means between *Concinna* and *Heptapot* after controling for variance and covariances. We discard the sign as we only care about magnitude of seperation. Now let's visualize this similar to the screeplot.

```{r clSepScreeplot}
.clSep <- abs(df_clusterSep_CH)
.clSep_rate <- t(.clSep[order(.clSep, decreasing = T)]) / sum(.clSep)
.var_nm_ord <- factor(row.names(.clSep_rate), levels=unique(row.names(.clSep_rate)))

df_Scree_ClSep <- data.frame(variable = .var_nm_ord,
                       rate_clSep = as.vector(.clSep_rate),
                       cumsum_rate_clSep = cumsum(.clSep_rate))

(g2 <- ggplot(data = df_Scree_ClSep) + 
    ## Individual clSep bars
    geom_bar(stat = "identity", 
             mapping = aes(x = variable, y = rate_clSep, 
                           fill = "Individual clSep explained")) + 
    ## Cummulative clSep line
    geom_line(mapping = aes(x = variable, y = cumsum_rate_clSep, group = 1,
                            color = "Cumsum of clSep explained"), lwd = 1.2) +
    geom_point(mapping = aes(x = variable, y = cumsum_rate_clSep,
                             color = "Cumsum of clSep explained"), shape = 18, size = 4) +
    ## Themes, legends and colors 
    theme_minimal() +
    labs(title = "Variables contributions to the seperation of cluster means [Concinna-Heptapot]",
         x = "Variable", 
         y = "Seperation of cluster means", 
         colour = "", fill = "") + 
    # theme(legend.position = c(0.9, 0.5)) + ## legend position doesn't work now because different geoms??
    scale_fill_manual(values = "#1B9E77") + 
    scale_colour_manual(values = "#D95F02"))
# RColorBrewer::brewer.pal(n=5, "Dark2")
```

## Evaluating the response

Now that we have a measure we want to define an objective cutoff for evaluation. We bin the seperation of clusters into 3 even bands relative to the max and assigned values of 0, 1, and 2 with increaing importance. Note that at least 1 variable must be "very important".

```{r answer}
bar100 <- max(.clSep_rate)
bar.66 <- 2 / 3 * bar100
bar.33 <- 1 / 3 * bar100

g2 +
  geom_rect(fill = "#7570B3", alpha = 0.05,
            mapping = aes(xmin = .3, xmax = 6.8, ymin = bar.66, ymax = bar100)) +
    geom_text(aes(x = 6.5, y = bar100 +.04, 
                  label = "max(single variable cluster seperation) | sample"), 
              size = 4, hjust = 1) +
  geom_hline(yintercept = bar100) +
  geom_text(aes(x = 6.5, y = bar.66 + .07, label = "very important -> 2"), 
            size = 4, hjust = 1) +
  geom_rect(fill = "#E7298A", alpha = 0.05,
            mapping = aes(xmin = .3, xmax = 6.8, ymin = bar.33, ymax = bar.66)) +
  geom_text(aes(x = 6.5, y = bar.33 + .07, label = "somewhat important -> 1"), 
            size = 4, hjust = 1) +
  geom_rect(fill = "#66A61E", alpha = 0.05,
            mapping = aes(xmin = .3, xmax = 6.8, ymin = 0, ymax = bar.33)) +
  geom_text(aes(x = 6.5, y = 0 + .07, label = "not important -> 0"), 
            size = 4, hjust = 1)
```

We make a $p$-length answer vector for the data set and find the variable-wise differnece with the response vector and aggregate over each variable acording to a measure where a larger value is worse.

$$MarksOff = \sum_{i = 1}^{p}(Answer_i - Response_i)^2$$

```{r exampleScoring}
df_Scree_ClSep$ptile_clSep <- df_Scree_ClSep$rate_clSep / bar100
df_taskEval <- data.frame(
  variable = df_Scree_ClSep$variable,
  answer =  dplyr::case_when(df_Scree_ClSep$rate_clSep > bar.66 ~ 2,
                             df_Scree_ClSep$rate_clSep > bar.33 ~ 1,
                             df_Scree_ClSep$rate_clSep >= 0 ~ 0),
  exampleResponse = c(2, 1, 1, 2, 0, 1))
df_taskEval$delta <- df_taskEval$answer - df_taskEval$exampleResponse
df_taskEval$var_marksOff <- df_taskEval$delta^2

kable(df_taskEval)
message(paste0("total MarksOff = ", sum(df_taskEval$var_marksOff)))
```

## Projected data view

All linear projections are nesciarily a lossy representation of the full data. By this we mean that no single 2D frame can show the whole set of infromation for $p>=3$ -dimensional sample. Any pair of Pricipal Components nessciaronly shows less than all the variation, namely the sum of their contributions, typicaly stated as percentage of full sample variation. Analogously any single projection cannot show the full information explain the cluster seperation of 2 given clusters.

In applcation, viewing a PC1 by PC2 biplot of flea data contains `r round(100*df_pcaVar[2,3],2)` percent of the variation explained in the sample. While viewing (an orthogonal project) the top 2 variables (namely: `r as.character(df_Scree_ClSep[1:2, 1])` ) explain `r round(100*df_Scree_ClSep[2, 3],2)` percent of the within sample cluster seperation between *Concinna* and *Heptapot*.

_finish this thought_

## Mental task

_todo_

# Simulation difficulty


In order to properly distinguish a difference between the 3 vizualization factors the data must be of suitable complexity, such that it has the following properties:

1. Must be complex enough not to see within the any pair of the first 4 Principal Components; such that PCA is not sufficent for exploring cluster seperation
2. Must not be so complex as to preclude any meaningful response given the factor visuals and time constraints.

Let's try to evaluate our current generation of data simulations against these properties

```{r simPcaPairs, eval=TRUE}
#### USES EVAL

## Series spans from 301:312
dat              <- readRDS("./apps/data/simulation_data301.rds")
dat_clusters     <- attributes(dat)$cl_lvl
dat_pca_rot      <- prcomp(dat)$rotation
proj_dat_pca_rot <- as.data.frame(as.matrix(dat) %*% dat_pca_rot)


library(GGally)
ggparis_proj_dat_pca <- 
  ggpairs(proj_dat_pca_rot[, 1:4], 
          title = "ggpairs of PC1:4 for simulation_data301",
          ggplot2::aes(colour = dat_clusters))
#scale_color_brewer("Dark2") ## scale_color/fill* don't work as explected on ggpairs()

ggplot2::ggsave(filename = "ggpairs_pca_sim301.png",
                plot =  ggparis_proj_dat_pca,
                path = "./output/")
```
![](output/ggpairs_pca_sim301.png)


Seems sufficent to be complex enough not to be seen as a pair of components within the first 4 Principal Components. Now to see if we can see anything in radial tours of all variables.

_note: spinifex needs cleanup_

```{r simRadialTours, eval=TRUE}
#### USES EVAL

## radial tours from a basis of PC1:2:
bas_pca <- dat_pca_rot[, 1:2]
dat_std <- tourr::rescale(dat) ## cl_lvls: class <- dat_clusters
library("spinifex")


if(F) {
  ns_play_radial_tour <- function(data,
                                  basis,
                                  manip_var = sample(1:ncol(data)),
                                  theta = NULL,
                                  render_type = render_gganimate,
                                  ...) {
    ### Test examples
    # data <- flea_std;basis <- rb; manip_var <- 1; theta = NULL; 
    # render_type <- render_gganimate;
    manip_space <- create_manip_space(basis = basis, manip_var = manip_var)
    mv_sp <- manip_space[manip_var, ]
    theta <- NULL
    if (is.null(theta)) {
      theta <- atan(basis[manip_var, 2] / basis[manip_var, 1])
      ### Was trying to incorprate the below this after CRAN ver, but not working. 
      # ang_minor <- atan(mv_sp[2] / mv_sp[1])
      # offset <- 270 + sign(mv_sp[1]) * 90
      # theta <- (offset + sign(mv_sp[1]) * sign(mv_sp[2]) * ang_minor) %% 360
    }
    tour_hist <- manual_tour(basis = basis, manip_var = manip_var, theta = theta, ...)
    tour_df   <- array2df(array = tour_hist, data = data)
    render_type(slides = tour_df, ...)
  }
  
  i_s <- 1:ncol(dat)
  # ls_dat_radial_tour <- list()
  for(i in i_s) {
    .this_radial_tour <- 
      ns_play_radial_tour(basis = bas_pca, data = dat_std, manip_var = i,
                          render_type = render_gganimate, 
                          col = col_of(dat_clusters), pch = pch_of(dat_clusters), 
                          axes = "bottomleft", fps = 8)
    .gif_filepath <- paste(".output/radialTour_sim301_mv", i, ".gif")
    gganimate::anim_save(.gif_filepath, .this_radial_tour)
    # ## store gganimate in a list obj that isn't currently used
    # ls_dat_radial_tour[[i]] <- .this_radial_tour 
    .this_radial_tour ## explicitly call the gganimate tour
  }
}
```
![](output/radialTour_sim301_mv1.gif)
![](output/radialTour_sim301_mv2.gif)
![](output/radialTour_sim301_mv3.gif)
![](output/radialTour_sim301_mv4.gif)
![](output/radialTour_sim301_mv5.gif)
![](output/radialTour_sim301_mv6.gif)
![](output/radialTour_sim301_mv7.gif)

# References


Fisher, Ronald A. "The Use of Multiple Measurements in Taxonomic Problems." Annals of Eugenics 7, no. 2 (September 1936): 179-88. https://doi.org/10.1111/j.1469-1809.1936.tb02137.x.


