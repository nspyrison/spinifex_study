---
title: "prolifico 100"
author: "Nick Spyrison"
date: "11/03/2021"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
header-includes:
   - \usepackage{amsmath}
   - \usepackage{showframe}
editor_options: 
  chunk_output_type: console
---
```{r setup, include=FALSE}
require(tidyverse)
require("lme4") ## Random Effects (RE) model creation
require("merTools")
require("performance") ## tidy model eval

knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
rel_path <- function(rel_path = "."){
  rel_dir  <- dirname(rstudioapi::getSourceEditorContext()$path)
  rel_path <- paste0(rel_dir, "/", rel_path)
  normalizePath(rel_path, winslash = "/")
}
```


```{r}
## Read from gsheets API4 and save local
if(F){
  ## Hash id of the google sheet
  ss_id <- "1K9qkMVRkrNO0vufofQJKWIJUyTys_8uVtEBdJBL_DzU" 
  raw <- googlesheets4::read_sheet(ss_id, sheet = 1L)
  ## Remove dummy rows
  raw <- raw %>% filter(!is.na(plot_active), ## dummy rows
                        nchar(stringr::str_trim(prolific_id)) == 24L) ## trimmed nchar(prolifico_id) = 24L
  ## Format 
  raw$full_perm_num = unlist(as.integer(raw$full_perm_num))
  raw$participant = unlist(as.character(raw$participant))
  dim(raw)
  saveRDS(raw, "./apps_supplementary/v4_prolifico_100/data/raw_prolific_100.rds")
}
## Load load and clean, save cleaned
if(F){
  raw <- readRDS(rel_path("data/raw_prolific_100.rds"))
  ## Only plot_active rows 
  ## AND Only participants (rows where nchar(participant) == 24 charcters long)
  dat_active <- raw %>% filter(plot_active == TRUE,
                               nchar(prolific_id) == 24L)
  source(file = rel_path("../../paper/R/clean_participant_data.r"),
         local = TRUE, echo = FALSE)
  ## pivot variables columns longer for task-grained aggregation.
  dat_longer <- dat_active %>% pivot_longer_resp_ans_tbl()
  ## Impute missing sec_to_resp, via mean diff with sec_on_pg
  .mean_diff <- mean(dat_longer$sec_on_pg, na.rm = TRUE) -
    mean(dat_longer$sec_to_resp, na.rm = TRUE)
  dat_longer <- dat_longer %>%
    mutate(sec_to_resp = dplyr::if_else(is.na(sec_to_resp), 
                                        sec_on_pg - .mean_diff, sec_to_resp))
  ## Aggregate to task grain.
  dat_task_agg <- aggregate_task_vars(dat_longer)
  ## Fix observeEvent() over count of radial input_inter. 
  dat_task_agg <- dat_task_agg %>% 
    dplyr::mutate(task_input_inter = dplyr::if_else(
      factor == "radial", task_input_inter -1L, task_input_inter))
  ## Plot friendly titles
  dat_task_agg <- dat_task_agg %>%
  mutate(instance_id = paste(sep = "_", participant_num, full_perm_num, prolific_id)) %>%
  rename(shape = vc, dim = p_dim, order = eval, participant = prolific_id,
         `is training` = is_training, `# response interactions` = task_resp_inter,
         `max seconds to respond` = max_sec_to_resp, `seconds on page` = max_sec_on_pg,
         `# of responses` = cnt_resp, marks = task_marks,
         `parameter permutation` = full_perm_num)
  ## Save task aggregated data.
  saveRDS(dat_task_agg, rel_path("data/dat_task_agg_prolific_100.rds"))
}
## load aggregated data.
dat_task_agg <- readRDS(rel_path("data/dat_task_agg_prolific_100.rds"))
## filter out raining data for now; is even eval is the new color/fill go to.
dat_task_agg <- dat_task_agg %>% filter(`is training` == FALSE)


## Local functions -----
## For labeling n, mean on boxplots, following:
#### https://medium.com/@gscheithauer/how-to-add-number-of-observations-to-a-ggplot2-boxplot-b22710f7ef80
my_theme <- list(
  theme_minimal(),
  scale_color_brewer(palette = "Dark2"),
  scale_fill_brewer(palette = "Dark2"),
  geom_hline(yintercept = 0L),
  theme(legend.position = "bottom",
        legend.box = "vertical",
        legend.margin = margin(-6))
)
my_ggplot <- function(.aes = aes(x = order, y = marks,
                                 color = `is even instance`, fill = `is even instance`),
                      .title = "Default title",
                      .data = dat_qual)
{
  ggplot(.data, .aes) +
    labs(title = .title) +
    my_theme +
    geom_point(
      position = position_jitterdodge(jitter.width = .3, jitter.height = .05), alpha = .2) +
    geom_boxplot(position = "dodge", alpha = .4)
}
```

______


## Even-ness of evaluation

Let's look at the distribution of quality evaluations by full_perm_num.

```{r}
#### Aggregation tables

## instance_agg
intance_agg <- dat_task_agg %>%
  group_by(instance_id, participant_num, `parameter permutation`, participant) %>%
  summarise(`n instance evals` = n()) %>% 
  ungroup() %>% 
  mutate(is_instance_even = if_else(`n instance evals` == 6, TRUE, FALSE)) %>% 
  arrange(desc(`n instance evals`))
## Find vector of evenly evaled instance_ids
even_evaled_instance_ids <- intance_agg %>%
  filter(is_instance_even == TRUE) %>%
  pull(instance_id)
## Decode the original dataset by evenness of instance_id.
dat_qual <- dat_task_agg %>% 
  mutate(`is even instance` = if_else(instance_id %in% even_evaled_instance_ids, TRUE, FALSE))
dat_qual_even <- dat_qual %>% filter(`is even instance` == TRUE)

## participant_agg
participant_agg <- dat_qual %>%
  group_by(participant, `is even instance`) %>%
  summarise(`even evaluations` = n() / 6) %>%
  ungroup() %>%
  arrange(desc(`even evaluations`))

## perm_num_agg
perm_num_agg <- dat_qual %>%
  group_by(`parameter permutation`, `is even instance`) %>%
  summarise(`even evaluations` = n() / 6) %>%
  ungroup() %>%
  arrange(desc(`even evaluations`))

## Remove all instances where the participant AND the permutation number are over evaluated
candidate_participants_for_removal <- participant_agg %>%
  filter(`is even instance` == TRUE,
         `even evaluations` > 1) %>% 
  pull(participant)
candidate_perm_num_for_removal <- perm_num_agg %>% 
  filter(`is even instance` == TRUE,
         `even evaluations` > 3) %>% 
  pull(`parameter permutation`)
intance_agg_over_eval <- intance_agg %>%
  mutate(`is over evaled participant` = if_else(participant %in% candidate_participants_for_removal, TRUE, FALSE),
         `is over evaled perm num` = if_else(`parameter permutation` %in% candidate_perm_num_for_removal, TRUE, FALSE),
         ## THESE ARE IDEAL FOR REMOVAL.
         `is over evaled participant and perm` = `is over evaled participant` & `is over evaled perm num`)
# Participant AND Parameter over evaled
canidate_instance_for_removal <- intance_agg_over_eval %>%
  filter(`is over evaled participant and perm` == TRUE) %>%
  pull(instance_id)

#### Plot Evenness:

## Evaluations by participant
ggplot(participant_agg, aes(x = participant, y = `even evaluations`,
                            color = `is even instance`, fill = `is even instance`)) +
  labs(title = "Evaluations by participant") +
  my_theme + 
  geom_bar(stat = "identity", position = "dodge") + geom_hline(yintercept = 1) +
  geom_text(aes(x = .95 * max(length(unique(participant))), y = 1.2,
                label = "ideal"), color = "black")

## Evaluations by parameter permutation
.mn_val <- sum(perm_num_agg$`even evaluations`[perm_num_agg$`is even instance` == TRUE], na.rm = TRUE) / 36
(gg_eval_by_perm_num <- perm_num_agg %>% 
    ggplot(aes(x = `parameter permutation`, y = `even evaluations`,
               color = `is even instance`, fill = `is even instance`)) +
  labs(title = "Evaluations by parameter permutaion") +
  my_theme + 
  geom_bar(stat = "identity", position = "dodge") + 
  geom_hline(yintercept = .mn_val, linetype = 2) +
  geom_hline(yintercept = 3, linetype = 1) + 
  geom_text(aes(x = 33, y = 3.2, label = "target"), color = "black") +
  geom_text(aes(x = 26, y = .mn_val + .2, label = "mean of even evaluations"), color = "black")
)

## Evaluation by pameter permutations with candidates removed
print(paste0("We have identfied ", length(canidate_instance_for_removal), " instances for removal where both the candidate and permutation number are over evaluated. if we remove these then the remaining permutation number eveness looks like:"))

perm_num_agg_removed <- dat_qual %>% 
  filter(!(instance_id %in% canidate_instance_for_removal)) %>% 
  group_by(`parameter permutation`, `is even instance`) %>%
  summarise(`even evaluations` = n() / 6) %>%
  ungroup() %>%
  arrange(desc(`even evaluations`))

.mn_val <- sum(perm_num_agg_removed$`even evaluations`[perm_num_agg_removed$`is even instance` == TRUE], na.rm = TRUE) / 36
(gg_eval_by_perm_num_removed <- perm_num_agg_removed %>% 
    ggplot(aes(x = `parameter permutation`, y = `even evaluations`,
               color = `is even instance`, fill = `is even instance`)) +
  labs(title = "Evaluations by parameter permutaion", 
       subtitle = "instances with over over evaluated participants AND permutations removed.") +
  my_theme + 
  geom_bar(stat = "identity", position = "dodge") + 
  geom_hline(yintercept = .mn_val, linetype = 2) +
  geom_hline(yintercept = 3, linetype = 1) + 
  geom_text(aes(x = 33, y = 3.1, label = "target"), color = "black") +
  geom_text(aes(x = 26, y = .mn_val + .1, label = "mean of even evaluations"), color = "black")
)

print("We want to futher extend the prolific crowdsourcing another 11 people, and an additional 3 people awaiting paid. We conservatively estimate this will be about 45 pounds.")
```



## Last response time density

I am concerned about the quality of the data, given that so many people experienced network issues. Let's explore.

```{r}
## Remove windsorizing
# print(paste0("N_raw = ", length(unique(dat_qual$participant)), " unique prolific ids"))
# lb <- quantile(dat_qual$`max seconds to respond`, probs = .25) ## bottom 25 %
# ub <- quantile(dat_qual$`max seconds to respond`, probs = .95) ## top 5 %
ann_offset <- 7
ggplot() + 
  geom_density(aes(`max seconds to respond`, fill = ""), dat_qual, alpha = .5) +
  ggtitle("Seconds to respond density") +
  my_theme +
  lims(x = c(0, 100)) +
  # geom_vline(xintercept = c(lb, ub), linetype = 2L) +
  geom_vline(xintercept = 60, linetype = 3L) +
  geom_label(aes(x =  60 - ann_offset, #c(lb + ann_offset, 60 - ann_offset, ub - ann_offset), 
                 y = .03, #c(.05, .045, .05), 
                 label = "plot turns off"#c("25th percentile", "plot turns off" ,"95th percentile")
  )) #+
  # annotate("rect", xmin = -Inf, xmax = lb, ymin = -Inf, ymax = Inf,
  #          alpha = 0.3, fill = "firebrick1") +
  # annotate("rect", xmin = lb, xmax = ub, ymin = -Inf, ymax = Inf,
  #          alpha = 0.3, fill = "aquamarine") +
  # annotate("rect", xmin = ub, xmax = Inf, ymin = -Inf, ymax = Inf,
  #          alpha = 0.3, fill = "firebrick1")

# dat_qual <- dat_qual
#%>% filter(`max seconds to respond` > lb, `max seconds to respond` < ub)
## windsorized conflicts with the within participant evaluation.

#print(paste0("N_windsorized = ", length(unique(dat_qual$participant)), " unique prolific ids"))
# obs_percent <- round(100L * nrow(dat_qual) / nrow(dat_task_agg), 2)
# paste0("Percent of original task evaluations in subset: ", obs_percent, "%")
# print("NOTE: The rest of the analysis we will be looking at this middle ~70% of the evaluations.")
```

```{r}
ggplot(dat_qual) + my_theme +
  geom_point(aes(`max seconds to respond`, marks,
                 fill = `is even instance`, color = `is even instance`), alpha = .2) +
  geom_smooth(aes(`max seconds to respond`, marks,
                  fill = `is even instance`, color = `is even instance`)) +
  ggtitle("Mark by last response time")
```


## Within-participants -- Marks by Evaluation order

```{r}
  ggplot(dat_qual_even,aes(x = factor, y = marks)) +
  geom_boxplot(alpha = .05) +
  labs(title = "Within Participants, Marks by factor") +
  scale_color_brewer(palette = "Dark2") + 
  scale_fill_brewer(palette = "Dark2") +
  geom_line(aes(frame = participant, group = participant),
            alpha = .2)
```


## Random effects regression models

We create a number of base models for comparison We have:

$$
\begin{align*}
\text{model F: } ~~~~~ \widehat{marks}_{partcipant~n} = 
  ~ &\beta_{0} + \Sigma_{f = 1}^3(\alpha_{factor~f} * \beta_{factor~f}) + 
  effect_{participant~n} + \epsilon \\
\text{model L: } ~~~~~ \widehat{marks}_{partcipant~n} =
  ~ &\beta_{0} + \Sigma_{l = 1}^3(\alpha_{location~l} * \beta_{location~l}) +
  effect_{participant~n} + \epsilon \\
\text{model S: } ~~~~~ \widehat{marks}_{partcipant~n} =
  ~ &\beta_{0} + \Sigma_{s = 1}^3(\alpha_{shape~s} * \beta_{shape~s}) +
  effect_{participant~n} + \epsilon \\
\text{model D: } ~~~~~ \widehat{marks}_{partcipant~n} =
  ~ &\beta_{0} + \Sigma_{d = 1}^2(\alpha_{dim~d} * \beta_{dim~d}) +
  effect_{participant~n} + \epsilon \\
\text{model O: } ~~~~~ \widehat{marks}_{partcipant~n} =
  ~ &\beta_{0} + \Sigma_{o = 1}^6(\alpha_{order~o} * \beta_{order~o}) +
  effect_{participant~n} + \epsilon \\
  
\text{model FL: } ~~~~~ \widehat{marks}_{partcipant~n} = ~ &\beta_{0} +
  \Sigma_{f = 1}^3(\Sigma_{l = 1}^3(\alpha_{factor~f*location~l} * \beta_{factor~f*location~l})) + \\
  &effect_{participant~n} + \epsilon \\

\text{model F+L+S+D+O: } ~~~~~ \widehat{marks}_{partcipant~n} = ~ &\beta_{0} +
  \Sigma_{f = 1}^3(\alpha_{factor~f} * \beta_{factor~f}) + 
  \Sigma_{l = 1}^3(\alpha_{location~l} * \beta_{location~l}) + \\
  &\Sigma_{s = 1}^3(\alpha_{shape~s} * \beta_{shape~s}) +
  \Sigma_{d = 1}^2(\alpha_{dim~d} * \beta_{dim~d}) + \\
  &\Sigma_{o = 1}^6(\alpha_{order~o} * \beta_{order~o}) + 
  effect_{participant~n} + \epsilon \\

\text{model FL+S+D+O: } ~~~~~ \widehat{marks}_{partcipant~n} = ~ &\beta_{0} +
  \Sigma_{f = 1}^3(\Sigma_{l = 1}^3(\alpha_{factor~f*location~l} * \beta_{factor~f*location~l})) + \\
  &\Sigma_{s = 1}^3(\alpha_{shape~s} * \beta_{shape~s}) +
  \Sigma_{d = 1}^2(\alpha_{dim~d} * \beta_{dim~d}) + \\
  &\Sigma_{o = 1}^6(\alpha_{order~o} * \beta_{order~o}) + 
  effect_{participant~n} + \epsilon \\

\text{model F(L+S+D)+O: } ~~~~~ \widehat{marks}_{partcipant~n} = ~ &\beta_{0} +
  \Sigma_{f = 1}^3(\Sigma_{l = 1}^3(\alpha_{factor~f*location~l} * \beta_{factor~f*location~l})) + \\
  &\Sigma_{f = 1}^3(\Sigma_{s = 1}^3(\alpha_{factor~f*shape~s} * \beta_{factor~f*shape~s}) + \\
  &\Sigma_{d = 1}^2(\Sigma_{s = 1}^2(\alpha_{factor~f*dim~d} * \beta_{factor~f*dim~d}) + \\
  &\Sigma_{o = 1}^6(\alpha_{order~o} * \beta_{order~o}) + 
  effect_{participant~n} + \epsilon \\

\end{align*}
$$

Where,
$$
\begin{align*}
&\beta_0 \text{ is the sum of the marginal intercept and the mean of the participant effect} \\
&\epsilon \sim \mathcal{N}(0,~\sigma) \\
&effect_{participant~n} \sim \mathcal{N}(0,~\tau_{participant~n}) ~|~ n \in (1,~... ~N) \\
&factor~f \in (pca,~grand,~radial) \\
&location~l \in (0/100,~33/66,~50/50) \text{ % mixing of a noise and signal variable respectively} \\
&shape~s \in (EEE,~EEV,~EVV~banana) \\
&dim~d \in (4,~6) \text{ variables with 3 & 4 clusters respectively} \\
&order~o \in (1,~... ~6) \text{, treated as a factor variable rather than numeric variable}
\end{align*}
$$

```{r}
## Mixed (fixed and random/variable) effects regression model,
### following along with:
if(F) 
  browseURL("https://m-clark.github.io/mixed-models-with-R/random_intercepts.html#running-a-mixed-model")
#install.packages("lme4")

## The Models:
m_factor <- lmer(marks ~ factor + (1 | participant), data = dat_qual)
m_location <- lmer(marks ~ location + (1 | participant), data = dat_qual)
m_shape <- lmer(marks ~ shape + (1 | participant), data = dat_qual)
m_dim <- lmer(marks ~ dim + (1 | participant), data = dat_qual)
m_order <- lmer(marks ~ order + (1 | participant), data = dat_qual)
m_param <- lmer(marks ~ `parameter permutation` + (1 | participant), data = dat_qual)
m_factorLocation <- 
  lmer(marks ~ factor * location + (1 | participant), data = dat_qual)
m_factor.location.dim.shape.order <- 
  lmer(marks ~ factor + location + dim + shape + order + (1 | participant), data = dat_qual)
m_factorLocation.dim.shape.order <- 
  lmer(marks ~ factor * location + dim + shape + order + (1 | participant), data = dat_qual)
m_factor_location.dim.shape_.order <- lmer(
  marks ~ factor * (dim + shape + location) + order + (1 | participant), data = dat_qual)

model_ls <- list(m_factor = m_factor,
                 m_location = m_location, 
                 m_shape = m_shape,
                 m_dim = m_dim,
                 m_order = m_order,
                 m_factorLocation = m_factorLocation,
                 m_factor.location.dim.shape.order = m_factor.location.dim.shape.order,
                 m_factorLocation.dim.shape.order = m_factorLocation.dim.shape.order,
                 m_factor_location.dim.shape_.order = m_factor_location.dim.shape_.order
)

## ggplot2 plot_residuals function 
plot_residual <- function(model){
  .df <- data.frame(predicted  = predict(model), 
                    residual = residuals(model),
                    factor = dat_qual$factor
  )
  p <- ggplot(.df, aes(x = predicted, y = residual, color = factor, shape = factor)) +
    geom_point(alpha = .33) + my_theme + ggtitle("Residuals by predcted values") + 
    theme(legend.position = "bottom",
          legend.box = "vertical",
          legend.margin = margin(-6))
  p <- ggExtra::ggMarginal(p, type = "density", fill = "grey80")
  return(p)
}
plot_REsim_qq <- function(model){
  .df <- data.frame(y = REsim(model)$mean)
  ggplot(.df, aes(sample = y)) + 
    stat_qq(alpha = .5) + stat_qq_line() + my_theme +
    ggtitle("qq plot of the mean of random effects simulation")
}

## lapply over models
performance_ls <- aic_ls <- bic_ls <- summary_ls <- plotREsim_ls <- 
  plot_REsim_qq_ls <- plot_residual_ls <- annova_ls <- list()
mute <- lapply(seq_along(model_ls), function(i){
  #print(paste0("fitting model: ", names(model_ls)[i])) 
  this_model <- model_ls[[i]]
  performance_ls[[i]] <<- performance::model_performance(this_model)
  # summary_ls[[i]] <<- summary(this_model)
  # plotREsim_ls[[i]] <<- plotREsim(REsim(this_model))
  # plot_REsim_qq_ls[[i]] <<- plot_REsim_qq(this_model)
  # plot_residual_ls[[i]] <<- plot_residual(this_model)
  # annova_ls[[i]] <<- anova(this_model)
})
.perf_df <- dplyr::bind_rows(performance_ls)
model_comp_tbl <- tibble(`Model name` = names(model_ls), 
                         `AIC` = round(.perf_df[, 1]),
                         `BIC` = round(.perf_df[, 2]),
                         `R2 (cond. on RE)` = round(.perf_df[, 3], 3),
                         `R2 (marg.; w/o RE)` = round(.perf_df[, 4], 3),
                         `RMSE` = round(.perf_df[, 6], 3)
)

format_column_extrema <- function(df, col, extrema = max, markup = "**"){ 
  ## c("*", "**", "~~"), c("italics", "bold", "strikethrough")
  v <- as.data.frame(df[, col])[, 1]
  ## Make sure values are not factors
  r_idx <- which(v == extrema(v))
  ## Update formatting
  v[r_idx] <- paste0(markup, v[r_idx], markup)
  df[, col] <- v
  return(df)
}

print("regressing marks ~ * + RE(participant)")
model_comp_tbl %>% 
  format_column_extrema(2, min) %>% 
  format_column_extrema(3, min) %>% 
  format_column_extrema(4, max) %>% 
  format_column_extrema(5, max) %>% 
  format_column_extrema(6, min) %>% 
  knitr::kable()
```


### Regressing against the time

Because factor uniquely performed so well, let's use it as a benchmark as compared to models:

- marks ~ factor + RE_participant -- benchmark
- marks ~ factor + RE_participant.data
- time ~ factor + RE_participant
- time ~ factor + RE_participant.data

```{r}
marks_f_re_partcipant <- lmer(marks ~ factor + (1 | participant), data = dat_qual)
marks_f_re_partcipant.data <- 
  lmer(marks ~ factor + (1 | participant) + (1 | sim_nm), data = dat_qual)
time_f_re_partcipant <- 
  lmer(`max seconds to respond` ~ factor + (1 | participant), data = dat_qual)
time_f_re_partcipant.data <- 
  lmer(`max seconds to respond` ~ factor + (1 | participant) + (1 | sim_nm), data = dat_qual)

model_ls2 <- list(marks_f_re_partcipant = marks_f_re_partcipant,
                  marks_f_re_partcipant.data = marks_f_re_partcipant.data,
                  time_f_re_partcipant = time_f_re_partcipant,
                  time_f_re_partcipant.data = time_f_re_partcipant.data
)

performance_ls2 <- list()
mute <- lapply(seq_along(model_ls2), function(i){
  this_model <- model_ls2[[i]]
  performance_ls2[[i]] <<- performance::model_performance(this_model)
})

.perf_df <- dplyr::bind_rows(performance_ls2)
model_comp_tbl2 <- tibble(`Model name` = names(model_ls2),
                          `AIC` = round(.perf_df[, 1]),
                          `BIC` = round(.perf_df[, 2]),
                          `R2 (cond. on RE)` = round(.perf_df[, 3], 3),
                          `R2 (marg., w/o RE)` = round(.perf_df[, 4], 3),
                          `RMSE` = round(.perf_df[, 6], 3)
)

knitr::kable(model_comp_tbl2)

print("Random effect of the dataset as compared to that of the participant:")
summary(marks_f_re_partcipant.data)
.resim <- REsim(marks_f_re_partcipant.data)
plotREsim(.resim)
.resim_data <- .resim %>%
  filter(groupFctr == "sim_nm") %>% 
  arrange(mean)
print("Most difficult and easiest datasets:")
head(.resim_data)
tail(.resim_data)
```

## Marks by ... 

### Factor

```{r}
(gg_marks_by_factor <- my_ggplot(
  .aes = aes(x = factor, y = marks,
             color = `is even instance`, fill = `is even instance`),
  .title = "Marks by factor",
  .data = dat_qual))
```

### Order, of evaluation

```{r}
(gg_marks_by_eval_order <- my_ggplot(.aes = aes(x = order, y = marks,
                     color = `is even instance`, fill = `is even instance`),
          .title = "Marks by evaluation order",
          .data = dat_qual))
```

### Shape, Variance-covariance 

```{r} 
(gg_marks_by_shape <- my_ggplot(aes(x = shape, y = marks,
              color = `is even instance`, fill = `is even instance`),
          "Marks by var-covariance",
          .data = dat_qual))
```

### Dimension

```{r}
(gg_marks_by_dim <- my_ggplot(aes(x = dim, y = marks,
              color = `is even instance`, fill = `is even instance`),
          "Marks by dimension",
          .data = dat_qual))
```

### Location, of signal mixing

```{r}
(gg_marks_by_location <- my_ggplot(aes(x = location, y = marks,
              color = `is even instance`, fill = `is even instance`),
          "Marks by location",
          .data = dat_qual))
```

#### Facet by factor

```{r}
my_ggplot(aes(x = location, y = marks,
              color = `is even instance`, fill = `is even instance`),
          "Marks by location, faceted by factor",
          .data = dat_qual) + facet_wrap(vars(factor))
```

#### Facet by covariance shape

```{r}
my_ggplot(aes(x = location, y = marks,
              color = `is even instance`, fill = `is even instance`),
          "Marks by location, faceted by covariance shape",
          .data = dat_qual) + 
  facet_wrap(vars(shape))
```

#### Facet by evaluation order

```{r}
my_ggplot(aes(x = location, y = marks,
              color = `is even instance`, fill = `is even instance`),
          "Marks by location, faceted by evaluation order",
          .data = dat_qual) + 
  facet_wrap(vars(order))
```

______

## Speed by factor, evaluation order

```{r}
my_ggplot(aes(x = factor, y = `max seconds to respond`,
              color = `is even instance`, fill = `is even instance`),
          "Seconds till last response by factor",
          .data = dat_qual) +
  coord_cartesian(ylim = c(0L, 70L))

my_ggplot(aes(x = order, y = `max seconds to respond`,
              color = `is even instance`, fill = `is even instance`),
          "Seconds till last response by evaluation order",
          .data = dat_qual) +
  coord_cartesian(ylim = c(0L, 70L))
```

______

## Input and response interactions

```{r}
my_ggplot(aes(x = factor, y = task_input_inter,
              color = `is even instance`, fill = `is even instance`),
          "Number of input interaction (throughness) by factor",
          .data = dat_qual) +
  coord_cartesian(ylim = c(0L, 30L))

my_ggplot(aes(x = factor, y = `# response interactions`,
              color = `is even instance`, fill = `is even instance`),
          "Number of response interaction (inverse confidence) by factor",
          .data = dat_qual)
```


## Manual saving
```{r}
if(F){
  
  gg_eval_by_perm_num ## evenness of perm num 
  gg_marks_by_factor
  gg_marks_by_eval_order
  gg_marks_by_shape
  gg_marks_by_dim
  gg_marks_by_location
  
  ## MODEL
  ## _Save model figures
  (figModel <- cowplot::plot_grid(r, resim, ncol = 2, rel_widths = c(3, 2)))
  ggsave("figModels.png", plot = figModel, path = "./paper/figures",
         device = "png", width = 8, height = 4, unit = "in")
  ## _Save model summary, annova, residual_df in as list.
  model_ls <- list(
    summary = s,
    anova = a,
    residual_df = resid_2
  )
  saveRDS(model_ls, file = "./paper/figures/model_ls.rds")
}

```