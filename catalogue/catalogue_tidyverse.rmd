---
title: "Catalogue -- tidyverse simulations"
output:
  html_document:
  toc: true
toc_depth: 3
---
```{r setup, include=F}
DO_RERUN_RADIAL_TOURS <- T

require(here)
source(here("./R/sim_tidyverse.r"))

theme_set(theme_minimal())
palette(RColorBrewer::brewer.pal(8, "Dark2"))
set.seed(20200923)

knitr::opts_chunk$set(
  echo      = FALSE,
  include   = TRUE,
  message   = FALSE, warning = FALSE, error = FALSE,
  results   = "markup",            ## Opts: "asis", "markup", "hold", "hide"
  fig.align = "center",            ## Opts: "left", "right", "center", "default"
  fig.width = 8, fig.height = 5,
  out.width = "100%",
  fig.pos   = "h", out.extra = "", ## Figures forced closer to chunk location.
  cache = FALSE, cache.lazy = FALSE
)
```

```{r, initialize}
## SETUP MODELS, MEANS
models <- c("EEE", "EEV", "EVV_banana")#, "EVV_boomerang")
p      <- 4
k_cl   <- 3
cl_obs <- 140 ## banana() expects evenly divisable by 5
mns <- ##___2 signal dim  | 2 noise dim
  list("cl a" = c(-1, -1,   0, 0),
       "cl b" = c( 1, -1,   0, 0),
       "cl c" = c(-1,  1,   0, 0))

## COVARIANCES
sd_coef <- 1
sd   <- sd_coef * 1#.07 ## .07 IS ROUGHLY ~ MCLUST5 paper with unit means.
#### DEFINE COMMON COVARIANCES
cov_circ <- matrix(c(sd,  0,   0,   0,
                     0,   sd,  0,   0,
                     0,   0,   sd,  0,
                     0,   0,   0,   sd),
                   ncol = 4, byrow = TRUE)
cov_elipse_pos <- matrix(c(sd,  .9,  0,   0,
                           .9,  sd,  0,   0,
                           0,   0,   sd,  0,
                           0,   0,   0,   sd),
                         ncol = 4, byrow = TRUE)
cov_elipse_neg <- matrix(c(sd,  -.9, 0,   0,
                           -.9, sd,  0,   0,
                           0,   0,  sd,   0,
                           0,   0,   0,   sd), 
                         ncol = 4, byrow = TRUE)
cov_elipse_pos_cor_noise <- matrix(c(sd,  .9,  0,   0,
                                     .9,  sd,  0,   0,
                                     0,   0,   sd,  .8,
                                     0,   0,   .8,  sd),
                                   ncol = 4, byrow = TRUE)
cov_elipse_neg_cor_noise <- matrix(c(sd,  -.9, 0,   0,
                                     -.9, sd,  0,   0,
                                     0,   0,   sd,  .8,
                                     0,   0,   .8,  sd),
                                   ncol = 4, byrow = TRUE)
#### ASSIGN LISTS OF 3 COMMON COVARRIANCES TO EACH MODEL
assign(paste0("covs_", models[1]), 
       list("cl a" = cov_elipse_pos,
            "cl b" = cov_elipse_pos,
            "cl c" = cov_elipse_pos))
assign(paste0("covs_", models[2]), 
       list("cl a" = cov_elipse_pos,
            "cl b" = cov_elipse_neg,
            "cl c" = cov_elipse_pos))
assign(paste0("covs_", models[3]), 
       list("cl a" = .2 * cov_circ,
            "cl b" = .05 * cov_circ, ## Apply banana() to cl_b 
            "cl c" = cov_elipse_neg))

# assign(paste0("covs_", models[4]), 
#        list("cl a" = .2 * cov_circ,
#             "cl b" = .05 * cov_circ, ## Apply boomerang() to cl_b 
#             "cl c" = cov_elipse_pos))


## LOCAL FUNCTIONS
this_sim <- function(cov_ls){ ## same means list and obs list
  sim_tidyverse(mns_ls = mns, cov_ls = cov_ls, 
                obs_per_cl = cl_obs)
}

this_pcs <- function(x){
  ## Di uses prcomp(scale = FALCE), but previously applied stdd() on vars.
  prcomp(x[, 2:(p+1)], scale = FALSE)$x
}
  
theme_pairs <- function(){
  list(theme_minimal(),
       scale_color_manual(values = palette()[1:k_cl]),
       scale_fill_manual( values = palette()[1:k_cl]))
}

this_ggpairs <- function(x, title){ ## Assumes class vector 'clas'
  GGally::ggpairs(as.data.frame(x), aes(color = clas, shape = clas)) +
    ggtitle(title) + theme_pairs()
}

this_pca_ggpairs <- function(pcs, title){ ## Assumes class vector 'clas'
  GGally::ggpairs(as.data.frame(pcs), aes(color = clas, shape = clas)) +
    ggtitle(title) + theme_pairs()
}

## ASSIGN GENERATED SIMS
assign(models[1], this_sim(get(paste0("covs_", models[1]))))
assign(models[2], this_sim(get(paste0("covs_", models[2]))))
assign(models[3], this_sim(get(paste0("covs_", models[3])))) 
## Apply banana() to cl b.
EVV_banana[EVV_banana$cl == "cl b", ] <- banana(EVV_banana[EVV_banana$cl == "cl b", ])
# assign(models[4], this_sim(get(paste0("covs_", models[4]))))
## Apply boomerang() to cl b.
# EVV_boomerang[EVV_boomerang$cl == "cl b", ] <-
#   boomerang(EVV_boomerang[EVV_boomerang$cl == "cl b", ])
clas <- get(models[1])$cl

## ASSIGN PCS
assign(paste0("pcs_", models[1]), this_pcs(get(models[1])))
assign(paste0("pcs_", models[2]), this_pcs(get(models[2])))
assign(paste0("pcs_", models[3]), this_pcs(get(models[3])))
# assign(paste0("pcs_", models[4]), this_pcs(models[4]))
```

Each simulation is `r k_cl * cl_obs` observations of `r p` varaibles (`r k_cl` clusters, with `r cl_obs` observations each). 
<!-- The standard deviation used is about `r sd_coef` times that used in the mclust figure (harder to see cluster seperation). -->

# Variable space

```{r variableSpace}
titles <- paste0(models, " -- Variable space")
this_ggpairs(get(models[1]), titles[1])
this_ggpairs(get(models[2]), titles[2])
this_ggpairs(get(models[3]), titles[3])
```

# Principal component space, scaled

```{r, scaledPcSpace}
## CALL PCA GGPAIRS (SCALED)
titles <- paste0(models, " -- Principal component space, scaled")
this_pca_ggpairs(get(paste0("pcs_", models[1])), titles[1])
this_pca_ggpairs(get(paste0("pcs_", models[2])), titles[2])
this_pca_ggpairs(get(paste0("pcs_", models[3])), titles[3])
```

# Radial tours

The starting basis initialized to PC1:2 of each model. Radial tours created for the top 3 variables.

```{r}
if(DO_RERUN_RADIAL_TOURS == TRUE){
  ## RADIAL TOURS of top 2 vars
  fp <- here("./catalogue/images/")
  i_s <- 1:length(models)
  for(i in i_s){ ## Loop over models; 1:3
    dat <- get(models[i])
    bas <- basis_pca(dat)
    titles <- paste0(models[i], " -- Radial tour of variable ", 1:3, ".")
    for(j in 1:3){ ## Loop over manip_vars; 1:3
      play_manual_tour(basis = bas, data = dat, manip_var = j,
                       fps = 9L, axes = "left",
                       render_type = render_gganimate,
                       aes_args = list(color = clas, shape = clas),
                       ggproto = list(theme_spinifex(), ggtitle(titles[j])),
                       gif_filename = paste0("radialTour_tidyverse_", models[i], 
                                             "_mvar",j, ".gif"),
                       gif_path = here("./catalogue/images/")
      )
    }
    print(paste0("Done with radial tours for model: ", models[i], ". ",
                 "Model", i, " of ", max(i_s), "."))
  }
}
```

## `r models[1]`

![](images/radialTour_tidyverse_EEE_mvar1.gif)
![](images/radialTour_tidyverse_EEE_mvar2.gif)
![](images/radialTour_tidyverse_EEE_mvar3.gif)

## `r models[2]`

![](images/radialTour_tidyverse_EVV_mvar1.gif)
![](images/radialTour_tidyverse_EVV_mvar2.gif)
![](images/radialTour_tidyverse_EVV_mvar3.gif)

## `r models[3]`

![](images/radialTour_tidyverse_Banana_mvar1.gif)
![](images/radialTour_tidyverse_Banana_mvar2.gif)
![](images/radialTour_tidyverse_Banana_mvar3.gif)

<!-- ## `r models[4]` -->

<!-- ![](images/radialTour_tidyverse_Boomerang_mvar1.gif) -->
<!-- ![](images/radialTour_tidyverse_Boomerang_mvar2.gif) -->
<!-- ![](images/radialTour_tidyverse_Boomerang_mvar3.gif) -->


# checking variance-covariance matrices

Lets 
```{r covCheck}
if(F)
  browseURL("https://stats.stackexchange.com/questions/30465/what-does-a-non-positive-definite-covariance-matrix-tell-me-about-my-data")
require("lqmm"); require("matrixcalc");
covs_ls <- list(
  "cov_circ" = cov_circ,
  "cov_elipse_pos" = cov_elipse_pos,
  "cov_elipse_neg" = cov_elipse_neg,
  "cov_elipse_pos_cor_noise" = cov_elipse_pos_cor_noise,
  "cov_elipse_neg_cor_noise" = cov_elipse_neg_cor_noise
)

for(i in 1:length(covs_ls)){
  cov <- covs_ls[[i]]
  print(paste0("cov: ", names(covs_ls)[i]))
  print(paste0("is non-singular matrix: ", matrixcalc::is.non.singular.matrix(cov)))
  IS_psd <- matrixcalc::is.positive.semi.definite(cov)
  print(paste0("is positive semi-definite: ", IS_psd))
  if(IS_psd == FALSE){
    print("(if not psd,) make positive definite: ")
    print(lqmm::make.positive.definite(cov))
  }
}

```

# {mclust} paper reference

Scrucca, Luca, Michael Fop, T. Brendan Murphy, and Adrian E. Raftery. "Mclust 5: Clustering, Classification and Density Estimation Using Gaussian Finite Mixture Models." The R Journal 8, no. 1 (August 2016): 289-317.

## mclust paper, Table 3 
![](./images/mclust_table3.png)

## mclust paper, Figure 2
![](./images/mclust_figure2.png)
