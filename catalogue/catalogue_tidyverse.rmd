---
title: "Catalogue -- tidyverse simulations, (1/3, no contamination) "
output:
  html_document:
  toc: true
toc_depth: 3
---
```{r setup, include=F}
DO_RERUN_RADIAL_TOURS <- F

require(here)
source(here("R/sim_tidyverse.r"))
source(here("R/boomerang.r"))

theme_set(theme_minimal())
palette(RColorBrewer::brewer.pal(8, "Dark2"))
set.seed(20200923)

knitr::opts_chunk$set(
  echo      = FALSE,
  include   = TRUE,
  message   = FALSE, warning = FALSE, error = FALSE,
  results   = "markup",            ## Opts: "asis", "markup", "hold", "hide"
  fig.align = "center",            ## Opts: "left", "right", "center", "default"
  fig.width = 8, fig.height = 5,
  out.width = "100%",
  fig.pos   = "h", out.extra = "", ## Figures forced closer to chunk location.
  cache = FALSE, cache.lazy = FALSE
)
```

```{r, initialize}
## SETUP MODELS, MEANS
models <- c("EEE", "EEV", "EVV_banana", "EVV_boomerang")
p      <- 4
k_cl   <- 3
cl_obs <- 140 ## banana() expects evenly divisable by 5
mns <- ##___2 signal dim  | 2 noise dim
  list("cl a" = c(-1, -1,   0, 0),
       "cl b" = c( 1, -1,   0, 0),
       "cl c" = c(-1,  1,   0, 0))

## COVARIANCES
sd <- 1 ## .07 IS ROUGHLY ~ MCLUST5 paper with unit means.
#### DEFINE COMMON COVARIANCES
cov_circ <- matrix(c(sd,  0,   0,   0,
                     0,   sd,  0,   0,
                     0,   0,   sd,  0,
                     0,   0,   0,   sd),
                   ncol = 4, byrow = TRUE)
cov_elipse_pos <- matrix(c(sd,  .9,  0,   0,
                           .9,  sd,  0,   0,
                           0,   0,   sd,  0,
                           0,   0,   0,   sd),
                         ncol = 4, byrow = TRUE)
cov_elipse_neg <- matrix(c(sd,  -.9, 0,   0,
                           -.9, sd,  0,   0,
                           0,   0,  sd,   0,
                           0,   0,   0,   sd), 
                         ncol = 4, byrow = TRUE)
cov_elipse_pos_cor_noise <- matrix(c(sd,  .9,  0,   0,
                                     .9,  sd,  0,   0,
                                     0,   0,   sd,  .8,
                                     0,   0,   .8,  sd),
                                   ncol = 4, byrow = TRUE)
cov_elipse_neg_cor_noise <- matrix(c(sd,  -.9, 0,   0,
                                     -.9, sd,  0,   0,
                                     0,   0,   sd,  .8,
                                     0,   0,   .8,  sd),
                                   ncol = 4, byrow = TRUE)
#### ASSIGN LISTS OF 3 COMMON COVARRIANCES TO EACH MODEL
assign(paste0("covs_", models[1]), 
       list("cl a" = cov_elipse_pos,
            "cl b" = cov_elipse_pos,
            "cl c" = cov_elipse_pos))
assign(paste0("covs_", models[2]), 
       list("cl a" = cov_elipse_pos,
            "cl b" = cov_elipse_neg,
            "cl c" = cov_elipse_pos))
assign(paste0("covs_", models[3]), 
       list("cl a" = .2 * cov_circ,
            "cl b" = .05 * cov_circ, ## Apply banana() to cl_b 
            "cl c" = cov_elipse_neg))
assign(paste0("covs_", models[4]),
       list("cl a" = .2 * cov_circ,
            "cl b" = .05 * cov_circ, ## Apply boomerang() to cl_b
            "cl c" = cov_elipse_pos))


## LOCAL FUNCTIONS
this_sim <- function(cov_ls){ ## Assumes same means, mns and obs per cl scalar, cl_obs
  sim_tidyverse(mns_ls = mns, cov_ls = cov_ls, 
                obs_per_cl = cl_obs)
}

this_pcs <- function(data){ ## Assumes cluster is in first var 
  ## Di uses prcomp(scale = FALCE), but previously applied stdd() on vars.
  df <- data.frame(cl = data$cl,
                   prcomp(data[, 2:(p+1)], scale = FALSE)$x)
  as_tibble(df)
}
  
theme_pairs <- function(){
  list(theme_minimal(),
       scale_color_manual(values = palette()[1:k_cl]),
       scale_fill_manual( values = palette()[1:k_cl]))
}

this_ggpairs <- function(x, title){ ## Assumes class vector 'clas'
  GGally::ggpairs(as.data.frame(x), aes(color = clas, shape = clas)) +
    ggtitle(title) + theme_pairs()
}

this_pca_ggpairs <- function(pcs, title){ ## Assumes class vector 'clas'
  GGally::ggpairs(as.data.frame(pcs), aes(color = clas, shape = clas)) +
    ggtitle(title) + theme_pairs()
}

## ASSIGN GENERATED SIMS
assign(models[1], this_sim(get(paste0("covs_", models[1]))))
assign(models[2], this_sim(get(paste0("covs_", models[2]))))
assign(models[3], this_sim(get(paste0("covs_", models[3])))) 
## Apply banana() to cl b.
EVV_banana[EVV_banana$cl == "cl b", ] <- banana(EVV_banana[EVV_banana$cl == "cl b", ])
assign(models[4], this_sim(get(paste0("covs_", models[4]))))
## Apply boomerang() to cl b.
EVV_boomerang[EVV_boomerang$cl == "cl b", 2:5] <-
  boomerang(EVV_boomerang[EVV_boomerang$cl == "cl b", 2:5])
clas <- get(models[1])$cl

## ASSIGN PCS
assign(paste0("pcs_", models[1]), this_pcs(get(models[1])))
assign(paste0("pcs_", models[2]), this_pcs(get(models[2])))
assign(paste0("pcs_", models[3]), this_pcs(get(models[3])))
assign(paste0("pcs_", models[4]), this_pcs(get(models[4])))
```

# Simulation design 

Each simulation is `r k_cl * cl_obs` observations of `r p` varaibles (`r k_cl` clusters, with `r cl_obs` observations each).
<!-- The standard deviation used is about `r #sd_coef` times that used in the mclust figure (harder to see cluster seperation). -->

```{r simDesign}
design <- data.frame(
  `Simulation factor` = c("no contamination", "noise dimensions correlated", 
                          "rotated (signal in all variables"), 
  `EEE family` = c("EEE", "EEE_noiseCor", "EEE_rot"), 
  `EEV family` = c("EEV", "EEV_noiseCor", "EEV_rot"),
  `EVV_banana family` = 
    c("EVV_banana", "EVV_banana_noiseCor", "EVV_banana_rot"),
  `EVV_boomerang family` = 
    c("EVV_boomerang", "EVV_boomerang_noiseCor", "EVV_boomerang_rot"),
  check.names = FALSE
)
knitr::kable(design)
```



# Variable space

```{r variableSpace}
titles <- paste0(models, " -- Variable space")
this_ggpairs(get(models[1]), titles[1])
this_ggpairs(get(models[2]), titles[2])
this_ggpairs(get(models[3]), titles[3])
```

# Principal component space

```{r, scaledPcSpace}
## CALL PCA GGPAIRS (SCALED)
titles <- paste0(models, " -- Principal component space")
this_pca_ggpairs(get(paste0("pcs_", models[1])), titles[1])
this_pca_ggpairs(get(paste0("pcs_", models[2])), titles[2])
this_pca_ggpairs(get(paste0("pcs_", models[3])), titles[3])
```

# Radial tours

The starting basis initialized to PC1:2 of each model. Radial tours created for the top 3 variables.

```{r}
if(DO_RERUN_RADIAL_TOURS == TRUE){
  ## RADIAL TOURS of top 2 vars
  fp <- here("./catalogue/images/")
  i_s <- 1:length(models)
  for(i in i_s){ ## Loop over models; 1:3
    dat <- get(models[i])[2:5]
    bas <- basis_pca(dat)
    titles <- paste0(models[i], " -- Radial tour of variable ", 1:3, ".")
    for(j in 1:3){ ## Loop over manip_vars; 1:3
      play_manual_tour(basis = bas, data = dat, manip_var = j,
                       fps = 9L, axes = "left",
                       render_type = render_gganimate,
                       aes_args = list(color = clas, shape = clas),
                       ggproto = list(theme_spinifex(), ggtitle(titles[j])),
                       gif_filename = paste0("radialTour_tidyverse_", models[i], 
                                             "_mvar",j, ".gif"),
                       gif_path = here("./catalogue/images/")
      )
    }
    print(paste0("Done with radial tours for model: ", models[i], ". ",
                 "Model", i, " of ", max(i_s), "."))
  }
}
```

## `r models[1]`

![](images/radialTour_tidyverse_EEE_mvar1.gif)
![](images/radialTour_tidyverse_EEE_mvar2.gif)
![](images/radialTour_tidyverse_EEE_mvar3.gif)

## `r models[2]`

![](images/radialTour_tidyverse_EEV_mvar1.gif)
![](images/radialTour_tidyverse_EEV_mvar2.gif)
![](images/radialTour_tidyverse_EEV_mvar3.gif)

## `r models[3]`

![](images/radialTour_tidyverse_EVV_banana_mvar1.gif)
![](images/radialTour_tidyverse_EVV_banana_mvar2.gif)
![](images/radialTour_tidyverse_EVV_banana_mvar3.gif)

## `r models[4]`

![](images/radialTour_tidyverse_EVV_boomerang_mvar1.gif)
![](images/radialTour_tidyverse_EVV_boomerang_mvar2.gif)
![](images/radialTour_tidyverse_EVV_boomerang_mvar3.gif)


# Checking variance-covariance matrices

Let's check if our component variance-covariance matrices are non-singular and postive semi-definate.

```{r covCheck}
if(F)
  browseURL("https://stats.stackexchange.com/questions/30465/what-does-a-non-positive-definite-covariance-matrix-tell-me-about-my-data")
require("lqmm"); require("matrixcalc");
covs_ls <- list(
  "cov_circ" = cov_circ,
  "cov_elipse_pos" = cov_elipse_pos,
  "cov_elipse_neg" = cov_elipse_neg,
  "cov_elipse_pos_cor_noise" = cov_elipse_pos_cor_noise,
  "cov_elipse_neg_cor_noise" = cov_elipse_neg_cor_noise
)

for(i in 1:length(covs_ls)){
  cov <- covs_ls[[i]]
  print(paste0("cov: ", names(covs_ls)[i]))
  print(paste0("is non-singular matrix: ", matrixcalc::is.non.singular.matrix(cov)))
  IS_psd <- matrixcalc::is.positive.semi.definite(cov)
  print(paste0("is positive semi-definite: ", IS_psd))
  if(IS_psd == FALSE){
    print("(if not psd,) make positive definite: ")
    print(lqmm::make.positive.definite(cov))
  }
}

```

# {mclust} paper reference

Scrucca, Luca, Michael Fop, T. Brendan Murphy, and Adrian E. Raftery. "Mclust 5: Clustering, Classification and Density Estimation Using Gaussian Finite Mixture Models." The R Journal 8, no. 1 (August 2016): 289-317.

## mclust paper, Table 3 
![](./images/mclust_table3.png)

## mclust paper, Figure 2
![](./images/mclust_figure2.png)
